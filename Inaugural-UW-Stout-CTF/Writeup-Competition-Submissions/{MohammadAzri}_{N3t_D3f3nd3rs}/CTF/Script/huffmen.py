import heapq

# Define the Huffman Tree Node
class MinHeapNode:
    def __init__(self, data, freq):
        self.data = data  # The character or string (for bigrams, it will be a string)
        self.freq = freq  # Frequency of the character/string
        self.left = None  # Left child
        self.right = None  # Right child

    def __lt__(self, other):
        return self.freq < other.freq


# Function to build the Huffman tree
def build_huffman_tree(frequencies):
    # Create a min-heap and insert all characters with their frequencies
    heap = []
    for data, freq in frequencies.items():
        heapq.heappush(heap, MinHeapNode(data, freq))

    # Build the tree by combining the two smallest nodes until one tree is left
    while len(heap) > 1:
        left = heapq.heappop(heap)
        right = heapq.heappop(heap)

        # Create a new node with frequency equal to the sum of the two nodes
        new_node = MinHeapNode('$', left.freq + right.freq)
        new_node.left = left
        new_node.right = right

        # Push the new node back into the heap
        heapq.heappush(heap, new_node)

    # The heap now contains the root of the Huffman Tree
    return heap[0]


# Function to generate the Huffman codes for all characters
def generate_huffman_codes(root, current_code, codes):
    if root is None:
        return

    # If the node is a leaf node, store the code for the character
    if root.data != '$':
        codes[root.data] = current_code

    # Recur for left and right subtrees
    generate_huffman_codes(root.left, current_code + '0', codes)
    generate_huffman_codes(root.right, current_code + '1', codes)


# Function to decode the binary string using the Huffman tree
def decode_huffman_tree(root, binary_string):
    decoded_string = ''
    current_node = root

    for bit in binary_string:
        if bit == '0':
            current_node = current_node.left
        else:
            current_node = current_node.right

        # If we reach a leaf node, add its character to the decoded string
        if current_node.left is None and current_node.right is None:
            decoded_string += current_node.data
            current_node = root  # Go back to the root of the tree

    return decoded_string


# Main function to decode the binary string
def decode(frequencies, binary_string):
    # Step 1: Build the Huffman Tree
    root = build_huffman_tree(frequencies)

    # Step 2: Decode the binary string using the Huffman Tree
    decoded_message = decode_huffman_tree(root, binary_string)

    return decoded_message


# Frequencies dictionary from your input
frequencies = {
    'co': 0.007352941176470588, 'me': 0.007352941176470588, 'e ': 0.01838235294117647, ' t': 0.01838235294117647,
    'to': 0.011029411764705883, 'o ': 0.011029411764705883, 'ou': 0.01838235294117647, 'ut': 0.007352941176470588,
    's ': 0.025735294117647058, 'CT': 0.007352941176470588, 'TF': 0.007352941176470588, ' I': 0.011029411764705883,
    "I'": 0.007352941176470588, "'m": 0.007352941176470588, 'm ': 0.011029411764705883, ' s': 0.007352941176470588,
    ' h': 0.007352941176470588, 'ha': 0.007352941176470588, 'y ': 0.007352941176470588, ' y': 0.007352941176470588,
    'yo': 0.007352941176470588, ' w': 0.007352941176470588, 'er': 0.007352941176470588, 're': 0.011029411764705883,
    ' a': 0.014705882352941176, 'ab': 0.007352941176470588, 'le': 0.007352941176470588, 't ': 0.022058823529411766,
    'th': 0.014705882352941176, 'hi': 0.007352941176470588, 'is': 0.011029411764705883, ' m': 0.007352941176470588,
    'es': 0.007352941176470588, 'ss': 0.007352941176470588, 'ag': 0.007352941176470588, 'e.': 0.007352941176470588,
    '. ': 0.011029411764705883, 'as': 0.011029411764705883, ' i': 0.014705882352941176, 'it': 0.011029411764705883,
    'ar': 0.007352941176470588, 'ur': 0.007352941176470588, 'ne': 0.007352941176470588, 'd ': 0.007352941176470588,
    ' o': 0.007352941176470588, 'on': 0.007352941176470588, ' c': 0.007352941176470588, 'la': 0.007352941176470588,
    'wa': 0.007352941176470588, '..': 0.007352941176470588, 'W': 0.022058823529411766, 'e': 0.058823529411764705,
    'l': 0.025735294117647058, 'c': 0.01838235294117647, 'o': 0.058823529411764705, 'm': 0.022058823529411766,
    ' ': 0.13970588235294118, 't': 0.05514705882352941, 'U': 0.007352941176470588, '-': 0.003676470588235294,
    'S': 0.007352941176470588, 'u': 0.022058823529411766, "'": 0.011029411764705883, 's': 0.05514705882352941,
    'C': 0.011029411764705883, 'T': 0.01838235294117647, 'F': 0.007352941176470588, '!': 0.007352941176470588,
    'I': 0.011029411764705883, 'h': 0.025735294117647058, 'a': 0.051470588235294115, 'p': 0.014705882352941176,
    'y': 0.029411764705882353, 'w': 0.011029411764705883, 'r': 0.03308823529411765, 'b': 0.014705882352941176,
    'd': 0.014705882352941176, 'i': 0.025735294117647058, 'g': 0.01838235294117647, '.': 0.022058823529411766,
    '?': 0.003676470588235294, 'n': 0.025735294117647058, 'f': 0.007352941176470588, 'A': 0.007352941176470588,
    'H': 0.003676470588235294, ':': 0.003676470588235294, 'O': 0.003676470588235294, '{': 0.003676470588235294,
    '0': 0.007352941176470588, 'L': 0.003676470588235294, 'Z': 0.003676470588235294, 'v': 0.003676470588235294,
    'E': 0.003676470588235294, '2': 0.003676470588235294, '3': 0.003676470588235294, 'N': 0.007352941176470588,
    'K': 0.003676470588235294, 'k': 0.003676470588235294, '8': 0.007352941176470588, 'J': 0.007352941176470588,
    '6': 0.007352941176470588, 'M': 0.003676470588235294, 'x': 0.003676470588235294, '7': 0.003676470588235294,
    '}': 0.003676470588235294
}

# Binary string provided by you
binary_string = "01110111101100111110011101100101001100001101000001001011101111110100111101110111101000111110000101010001100101101011100000101011010111011111111111010110100000011000011000011000001111011111101100111001001110110000100101101001111001101011000011010011011011110101011001000111100000110100011110111001011110000000000000110110111111111111110000101110101111111110000100011000011001000110110111111011101101011101111100110100111000100011101101110011111111100011010100111001101000111010111110000001111010011010011100011110111001011111111010100111010100110000100001111101011101000011100110101001110100101011111011010010111110010000000000011101011000010100000100000000111110101010010000011110111001001101010010111010001101111101100100101111111011110011000110001001111100111110000011010101101001111100000001011110010110011011011001000011011000010010010111111111000010011010000011111100100010100101000001000011110111010101000100010001001010101110010110101110110010001110101010001011110011000110011001010101101111010111001101011101101111011111001100110101000101101110001111011111101011101000001110010111100100111100011101111001001110010101110100010111110001110101111101011011111101101101000010001101101011111010100110101100100010111010001010100010001001010101101100000101"

# Decode the message
decoded_message = decode(frequencies, binary_string)

# Print the decoded message
print(decoded_message)
